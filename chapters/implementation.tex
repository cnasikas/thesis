%!TEX root = ../thesis.tex

\tikzstyle{database} = [cylinder, shape border rotate=90, aspect=0.5, draw, fill=green!30],
\tikzstyle{node} = [rectangle, minimum width=4cm, minimum height=1cm, text centered, draw=black, draw, fill=blue!30],
\tikzstyle{blockchain} = [draw,rectangle,minimum width=\textwidth, minimum height=1cm,anchor=west, fill=orange!30],
\tikzstyle{process} = [fill=red!30],
\tikzstyle{txt} = [],
\tikzstyle{entity} = [draw, minimum height=1cm, minimum width=4cm, fill=blue!30]
\tikzstyle{com} = [<->]
\tikzstyle{block} = [draw,thick,inner sep=10pt]
\tikzset{barstyle/.style 2 args={
      draw,
      minimum height=3em,
      fill=orange!30,
      fit={(#1.west) (#1.east)}, inner sep=0pt, label={center:#2}
    }
}

\chapter{Implementation}
\label{implemenation}

As mention at §~\ref{solution} the Blockchain act as the controller of the network. As a result, the application is separated in two parts. The off-chain network and the Blockchain network. The dataset storage, transmission and processing lives off-chain while dataset registration, requests for processing, processing outputs and Zero Knowledge proofs leave on the Blockchain. Every node on the network---a data share node--- is connected to the Blockchain and track every transaction specified for the application. That way it can track and index every registered dataset, request for processing and processing outputs and proofs and act accordingly.

\section{RESTful API}
\label{implemenation:rest}

A RESTful API is provided to facilitate communication between any application, that follows the REST architecture, and the data sharing Blockchain ecosystem. The REST API expose the blockchain business network that can be easily consumed by HTTP or REST clients. That way, any developer familiar with existing web technologies and frameworks is not obligated to learn the interval mechanisms of a Blockchain system to develop and deploy applications atop.

Through the REST API one can:

\begin{itemize}
  \item Get all datasets
  \item Register a dataset
  \item Get a specific dataset
  \item Get all processing requests
  \item Register a request for processing
  \item Get a specific request
  \item Get all processors
  \item Register a processor
  \item Get all Blockchain accounts
\end{itemize}

The REST API expose a set of routes each one having an HTTP method and a URI. All available routes are shown at Table~\ref{table:api_routes}.

\begin{table}[ht!]
\centering
\begin{tabular}{|l|l|}
\hline
 Method & URI  \\ \hline
 GET & /\  \\ \hline
 GET &  /contracts \\ \hline
 GET &  /datastore \\ \hline
 GET &  /datastore/\{data\} \\ \hline
 POST &  /datastore\\ \hline
 GET &  /accounts \\ \hline
 GET &  /accounts/\{account\} \\ \hline
 GET &  /requests \\ \hline
 GET &  /requests/\{request\} \\ \hline
 POST &  /requests \\ \hline
 GET &  /processors \\ \hline
 POST &  /processors \\ \hline
\end{tabular}
\caption{RESTful API Routes}
\label{table:api_routes}
\end{table}

\section{Distributed Application}
\label{implemenation:dapp}

The distributed application is a web-based application providing a graphical user interface (UI) to facilitate the data sharing platform usage. The goal of the distributed application is to provide to the end-user an easy, self-explanatory and efficient way of interacting with the data sharing ecosystem. As most users are already familiar with the use of web applications and platforms, such as webmails, cloud services and social media, such interfaces makes the user feel accustomed. The user does not and should not need to know that interacts with a Blockchain icosystem.

The distributed application consumes the REST API and yields the same functionalities.

\section{Controller}
\label{implemenation:controller}

The controller is a data sharing node that is connected to the Blockchain and listens for processing requests. See §~\ref{solution:entities:data_controller} and §~\ref{solution:flow:pr_req} for more information.

\section{Processor}
\label{implemenation:processor}

The controller is a data sharing node that is connected to the Blockchain and listens for processing notifications by a controller node.  See §~\ref{solution:entities:data_processor} and §~\ref{solution:flow:pr_data} for more information.

\section{Libraries}
\label{implemenation:libs}

\subsection{Blockchain}
\label{implemenation:libs:bl}

The Blockchain library offers a set of functionalities that makes communication with any Blockchain implementation easier. Is a wrapper library over Blockchain specific libraries, such as Ethereum's \verb|web3|, and it's main purpose is to be Blockchain agnostic allowing the use of different Blockchains. For the moment only the Ethereum Blockchain is supported.

Abstract Functions:

\begin{itemize}
  \item \verb|isConnected|: Return true if a connection to a Blockchain node exists and false otherwise.
  \item \verb|getProvider|: Get the current provider (Blockchain node)
  \item \verb|setProvider|: Set provider (Blockchain node)
  \item \verb|getBalance|: Get the balance of an address
  \item \verb|setDefaultAccount|: Set the default address
  \item \verb|getDefaultAccount|: Get the default address
  \item \verb|getAccounts|: Get all accounts
  \item \verb|getLibInstance|: Get the Blockchain library
  \item \verb|getFilter|: Get a filter object
  \item \verb|toBytes|: Covert string to bytes
  \item \verb|fromBytes|: Covert bytes to string
\end{itemize}

\subsection{Crypto}
\label{implemenation:libs:cr}

The crypto library provides cryptographic functionality that includes a set of wrappers for \verb|SJCL| and \verb|Node.js Crypto module| functions.

Functions:

\begin{itemize}
  \item \verb|generateKeyPair|: Generate an asymmetric encryption key pair
  \item \verb|generateKey|: Generate a symmetric encryption key
  \item \verb|pubEncrypt|: Encrypt a string with a public key
  \item \verb|pubDecrypt|: Decrypt a ciphertext with a secret key
  \item \verb|encryptFile|: Encrypt a file with a symmetric key
  \item \verb|decryptFile|: Decrypt a file with a symmetric key
  \item \verb|bytesToHex|: Convert bytes to hex
  \item \verb|hextoBytes|: Convert hex to bytes
  \item \verb|hashFile|: Hash a file with SHA256
  \item \verb|hash|: Hash an array of values with SHA256
\end{itemize}

\section{Command-line interface}
\label{implemenation:cli}

A Command-line interface that provides a set of useful commands for the data sharing application.

Usage:

\begin{verbatim}
  $ node data-cli <options>
\end{verbatim}

Options:

\begin{itemize}
  \item \verb|-v| or \verb|--version|: Output the version number
  \item \verb|-g| or \verb|--generate-keys|: Generate an asymmetric
  \item \verb|-k| or \verb|--generate-key|: Generate a symmetric key
  \item \verb|-d| or \verb|--dummy-file <file>|: Generate a 45MB dummy file
  \item \verb|-e| or \verb|--encrypt-file <file>|: Encrypt a file
  \item \verb|-a| or \verb|--evaluation <bytes>|: Evaluate gas cost of bytes on Ethereum
  \item \verb|-s| or \verb|--hash <hash>|: Hash an array of values with SHA256
  \item \verb|-f| or \verb|--hash-file <file>|: Hash a file with SHA256
  \item \verb|-h| or \verb|--help|: Output usage information
\end{itemize}

\section{Smart contracts}
\label{implemenation:contracts}

The data sharing application is governed by a smart contract deployed on the Ethereum network. The smart contract allows data controllers to register new data sets, processor registration and request for data set processing. The Data Sharing smart contract is public available and can be used by any other contract in the network.

\subsection{Data set registration}
\label{implemenation:contracts:data_reg}

In order to register a new data set to the application the data controller needs to register with the smart contract by sending a \verb|registerDataSet| transaction with the following values:

\begin{itemize}
  \item \verb|_id|: The id of the data set. Data sets ids must be unique and will be converted to lowercase. It can be any string as long as it have not been already registered and it's length is less that 32
  \item \verb|name|: The name of the data set. It can be an arbitrary string
  \item \verb|location|: The URI of the location of the data set
  \item \verb|category|: The category of the data set. It can be an arbitrary string
  \item \verb|hashMeta|: The SHA256 of the submitted values
  \item \verb|_dataOwner|: The address of the owner of the data source
  \item \verb|digest|: The SHA256 of the raw data set
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Data set registration function}]
  function registerDataSet(
        bytes32 _id,
        string name,
        string location,
        string category,
        string hashMeta,
        address _dataOwner,
        string digest
  ) public returns (bool success);
\end{lstlisting}

\subsection{Request for processing}
\label{implemenation:contracts:req_pr}

The request for processing consists of two parts: A show of interest by a requestor for data processing and a notification to the processor informing that there is a request that needs attention.

In order to request for data processing a \verb|requestProcessing| transaction needs to be sent with the following values:

\begin{itemize}
  \item \verb|_dataSetID|: The dataset id of interest
  \item \verb|_subscriber|: The address of the requestor
  \item \verb|queryID|: The id of the query that the processor will execute over the data set
  \item \verb|pubKey|: The public key of the requestor
\end{itemize}

In order to notify a data processor that there is an available request for processing a \verb|notifyProcessor| transaction needs to be sent with the following values:

\begin{itemize}
  \item \verb|_providerAddress|: The address of the owner of the data source
  \item \verb|_subscriber|: The address of the requestor
  \item \verb|cipher|: The encryption of symmetric key with which the dataset had been encrypted
\end{itemize}

Normally the \verb|notifyProcessor| transaction is sent internally by the data controller that listen to data requests and want to forward the symmetric key to the processor.


\begin{lstlisting}[language=Solidity, caption={Request for processing functions}]
  function requestProcessing(
    bytes32 _dataSetID,
    address _subscriber,
    bytes32 queryID,
    string pubKey
  ) public returns (bool success);

  function notifyProcessor(
    address _providerAddress,
    address _subscriber,
    string cipher
  ) public returns (bool success);

\end{lstlisting}

\subsection{Processor Registration}
\label{implemenation:contracts:reg_processor}

In order for a data processor to be register a \verb|registerProcessor| transaction need to be sent with the following values:

\begin{itemize}
  \item \verb|_processorAddress|: The address of data processor
  \item \verb|name|: The name of the processor. It can be an arbitrary string
  \item \verb|pubKey|: The public key of the processor
\end{itemize}

Only the contract creator can execute the \verb|registerProcessor| function.

\begin{lstlisting}[language=Solidity, caption={Data processor registration function}]
  function registerProcessor(
    address _processorAddress,
    bytes32 name,
    string pubKey
  ) public returns (bool success);
\end{lstlisting}

\subsection{Data Controller Registration}
\label{implemenation:contracts:reg_processor}

In order for a data processor to be register a \verb|registerProvider| transaction need to be sent with the following values:

\begin{itemize}
  \item \verb|_providerAddress|: The address of data controller
  \item \verb|name|: The name of the processor. It can be an arbitrary string
  \item \verb|pubKey|: The public key of the processor
\end{itemize}

Only the contract creator can execute the \verb|registerProvider| function.

\begin{lstlisting}[language=Solidity, caption={Data controller registration function}]
  function registerProvider(
    address _providerAddress,
    bytes32 name,
    string pubKey
  ) public returns (bool success);
\end{lstlisting}

\subsection{General functions}
\label{implemenation:contracts:general}

\begin{itemize}
  \item \verb|getDataSetInfo|: Given a data set id it returns all the information of the data set
  \item \verb|getRequestInfo|: Given a requestor address it returns all the information of the request
  \item \verb|getDataProviderInfo|: Given a data controller address it returns all the information of the data controller
  \item \verb|getDataProcessorInfo|: Given a data processor address it returns all the information of the data processor
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={General functions}]
  function getDataSetInfo(bytes32 _dataSetID)
    public
    view
    returns(
          string name,
          string location,
          string category,
          address owner,
          string hashMeta,
          string digest
      );

  function getRequestInfo(address _subscriber)
    public
    view
    returns(
      bytes32 dataSetID,
      address provider,
      bool hasProof,
      bool processed,
      bytes32 queryID,
      string pubKey
  );

  function getDataProviderInfo(address provider)
    public
    view
    returns(
      address owner,
      bytes32 name,
      string pubKey
  );

  function getDataProcessorInfo(address _dataProcessorAddress)
  public
  view
  returns(
      address owner,
      bytes32 name,
      string pubKey
  );
\end{lstlisting}

\subsection{Process output and Zero Knowledge Proof}
\label{implemenation:contracts:zkp}

\subsection{Events}
\label{implemenation:contracts:events}

For every transaction that is sent to the data share smart contract that executes a function an event is being triggered. Every node of the network can register to listen to those events.

Events:

\begin{itemize}
  \item \verb|NewDataSet|: A data set is being registered
  \item \verb|NewProvider|: A data controller is being registered
  \item \verb|NewProcessor|: A data processor is being registered
  \item \verb|NewRequest|: A request for processing is being made
  \item \verb|Process|: A notification for data processing is being sent to a specific processor
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Data sharing application events}]

  event NewDataSet(
    bytes32 _id,
    string name,
    string location,
    string category,
    string hashMeta,
    address owner,
    string digest
  );

  event NewProvider(
    address _providerAddress,
    bytes32 name
  );

  event NewProcessor(
    address _providerAddress,
    bytes32 name,
    string pubKey
  );

  event NewRequest(
    bytes32 _dataSetID,
    address _provider,
    address _subscriber,
    bytes32 queryID,
    string pubKey
  );
  event Process(
    address _providerAddress,
    address _subscriber,
    string cipher
  );
\end{lstlisting}

\section{Zero Knowledge Proofs}
\label{implemenation:zkp}

For zkSNARKs proof generation and verification the \verb|Pequin| library~\cite{pequin} was used. \verb|Pequin| is a toolchain to verifiably execute programs expressed in the C programming language. \verb|Pequin| consists of a front-end and a back-end. The front-end takes C programs and transforms them to a set of arithmetic constraints. The back-end in Pequin is a zk-SNARK. Pequin uses \verb|SCIPR Lab's libsnark|~\cite{libsnark}, which is an optimized implementation of the back-end of \verb|Pinocchio|~\cite{pinocchio-nearly-practical-verifiable-computation}, itself a refinement and implementation of \verb|GGPR|~\cite{ggpr}.

\section{Programming details}
\label{implemenation:details}

Building the data sharing ecosystem (§~\ref{solution}) requires the use of various frameworks, technologies, programming languages and libraries.

In particular:

\begin{enumerate}
  \item RESTful API: \verb|Node.js v8.9.4|~\cite{nodejs}, \verb|Express 4.16.2|~\cite{expressjs}
  \item Command-line interface: \verb|Node.js v8.9.4|
  \item Distributed application: \verb|React 15.6.1|~\cite{react}, \verb|Redux 3.7.2|~\cite{redux} and \verb|Bootstrap 4.0.0|~\cite{bootstrap}
  \item Processor node: \verb|Node.js v8.9.4|
  \item Controller node: \verb|Node.js v8.9.4|
  \item Libraries:
    \begin{enumerate}
      \item Blockchain: \verb|web3 0.20.4|~\cite{web3js}
      \item Crypto: \verb|SJCL 1.0.7|~\cite{sjcl} and \verb|Node.js v8.9.4 Crypto Module|
    \end{enumerate}
  \item Smart contracts: \verb|Truffle 4.1.0|~\cite{truffle} and \verb|Solidity 0.4.19|~\cite{solidity}
  \item Zero Knowledge Proofs: \verb|Pequin|~\cite{pequin} and \verb|libsnark|~\cite{libsnark}
  \item Ethereum Blockchain: \verb|Ganache CLI v6.0.3 (ganache-core: 2.0.2)|~\cite{ganache}
\end{enumerate}

All code written in \verb|JavaScript| follows the \verb|ES6 (ECMAScript 2015)|~\cite{ECMA_2015} standard and the  \verb|StandardJS|~\cite{stdjs} style guide.

\begin{figure}[ht!]
  \center
  \begin{tikzpicture}
    \begin{scope}[node distance=2cm]
      \node[entity] (api) {API};
      \node[entity] (dapp) [above=of api] {Dapp};
      \node[entity] (eth_node) [below=of api] {Ethereum node};
      \node[database] (db) [right=of api, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (api) -- (eth_node);
    \draw[com] (api) -- (dapp);
    \draw[com] (api.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(dapp) (eth_node) (db), label={Local Enviroment}] (local) {};

    \node[barstyle={local}{Ethereum Blockchain}, below=of local] (blockchain) {};

    \draw[com] (eth_node.south) ++ (south:0ex) -- ++ (south:1.35cm);

  \end{tikzpicture}
  \caption{REST API \& Dapp implemenation scheme}
  \label{fig:implemenation:rest}
\end{figure}

\begin{figure}[ht!]
  \center
  \begin{tikzpicture}

    \begin{scope}[node distance=2cm]
      \node[entity] (controller) {Controller};
      \node[entity] (eth_node) [below=of controller] {Ethereum node};
      \node[database] (db) [right=of controller, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (controller) -- (eth_node);
    \draw[com] (controller.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(controller) (eth_node) (db), label={Local Enviroment}] (local) {};

    \node[barstyle={local}{Ethereum Blockchain}, below=of local] (blockchain) {};

    \draw[com] (eth_node.south) ++ (south:0ex) -- ++ (south:1.35cm);

    \begin{scope}[node distance=2cm]
      \node[entity] (eth_node_pr) [below=of blockchain, xshift=-2cm, yshift=0.65cm] {Ethereum node};
      \node[entity] (processor) [below=of eth_node_pr] {Processor};
      \node[entity] (zkp) [below=of processor] {ZKP Oracle};
      \node[database] (db_pr) [right=of processor, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (eth_node_pr.north) ++ (north:0ex) -- ++ (north:1.35cm);
    \draw[com] (processor) -- (eth_node_pr);
    \draw[com] (processor) -- (zkp);
    \draw[com] (processor.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(eth_node_pr) (processor) (db_pr) (zkp), label={below:Local Enviroment}] (local) {};

  \end{tikzpicture}
  \caption{Data processor and data controller implemenation scheme}
  \label{fig:implemenation:con_pr}
\end{figure}
