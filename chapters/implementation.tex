%!TEX root = ../thesis.tex
\chapter{Implementation}
\label{implemenation}

To cover the needs of the data sharing ecosystem the application is separated in two parts: the off-chain network and the blockchain network. The off-chain network is responsible for dataset storage, dataset distribution, and dataset processing. The blockchain is responsible for recording dataset registrations, requests for processing and processing outputs along with proofs of computations. For that reason, every node of the network---a data share node--- is connected to the blockchain and track every transaction specified for the application. This way it can track and index every registered dataset, all requests for processing and all processing outputs and proofs which in turn the node can act accordingly.

To implement those functionalities and services a variety of tools and APIs are made. They are analyzed in the following sections.

\section{RESTful API}
\label{implemenation:rest}

A RESTful API is provided to facilitate communication between any application, that follows the REST architecture, and the data sharing ecosystem. The REST API expose the blockchain business network that can be easily consumed by HTTP or REST clients. That way, any developer familiar with existing web technologies and frameworks is not obligated to learn the interval mechanisms of the blockchain system to develop and deploy applications atop.

Through the REST API one can:

\begin{itemize}
  \item Get all datasets
  \item Register a dataset
  \item Get a specific dataset
  \item Get all processing requests
  \item Register a request for processing
  \item Get a specific request
  \item Get all processors
  \item Register a processor
  \item Get all blockchain accounts
\end{itemize}

The REST API expose a set of routes each one having an HTTP method and a URI. All available routes are shown at Table~\ref{table:api_routes}.

\begin{table}[ht!]
\centering
\caption{RESTful API Routes}
\begin{tabular}{|l|l|}
\hline
 Method & URI  \\ \hline
 GET & /\  \\ \hline
 GET &  /contracts \\ \hline
 GET &  /datastore \\ \hline
 GET &  /datastore/\{data\} \\ \hline
 POST &  /datastore\\ \hline
 GET &  /accounts \\ \hline
 GET &  /accounts/\{account\} \\ \hline
 GET &  /requests \\ \hline
 GET &  /requests/\{request\} \\ \hline
 POST &  /requests \\ \hline
 GET &  /processors \\ \hline
 POST &  /processors \\ \hline
\end{tabular}
\label{table:api_routes}
\end{table}

\section{Distributed Application}
\label{implemenation:dapp}

The distributed application is a web-based application providing a graphical user interface (UI) to facilitate the data sharing platform usage. The goal of the distributed application is to provide to the end-user an easy, self-explanatory and efficient way of interacting with the data sharing ecosystem. As most users are already familiar with the use of web applications and platforms, such as webmails, cloud services and social media, such interfaces makes the user feel accustomed. The user does not and should not need to know that interacts with the blockchain.

The distributed application consumes the REST API and yields the same functionalities.

\section{Controller}
\label{implemenation:controller}

The controller is a data sharing node that is responsible for providing a dataset for data processing. It listens for processing requests and forwards the dataset to a data processor. Is implemented as described in §~\ref{solution:entities:data_controller} and §~\ref{solution:flow:pr_req}.

\section{Processor}
\label{implemenation:processor}

The processor is a data sharing node that is waiting for data processing notifications from a data controller. It is also connected to the blockchain and when it is notified for processing it processes the dataset and produces a Zero Knowledge proof for the correctness of the computation. Is implemented as described in §~\ref{solution:entities:data_processor} and §~\ref{solution:flow:pr_data}.

\section{Libraries}
\label{implemenation:libs}

Various libraries have been build to facilitate the interaction with the various components of the system. Each one is analyzed in the following sections.

\subsection{Blockchain}
\label{implemenation:libs:bl}

The blockchain library offers a set of functionalities that makes communication with any blockchain implementation easier. Is a wrapper library over blockchain specific libraries, such as Ethereum's \verb|web3|, and it's main purpose is to be blockchain agnostic allowing the use of different Blockchains. For the moment only the Ethereum blockchain is supported.

Abstract Functions:

\begin{itemize}
  \item \verb|isConnected|: Return true if a connection to a blockchain node exists and false otherwise.
  \item \verb|getProvider|: Get the current provider (blockchain node)
  \item \verb|setProvider|: Set provider (blockchain node)
  \item \verb|getBalance|: Get the balance of an address
  \item \verb|setDefaultAccount|: Set the default address
  \item \verb|getDefaultAccount|: Get the default address
  \item \verb|getAccounts|: Get all accounts
  \item \verb|getLibInstance|: Get the instance of the blockchain library
  \item \verb|getFilter|: Get a filter object
  \item \verb|toBytes|: Covert a string to bytes
  \item \verb|fromBytes|: Covert bytes to a string
\end{itemize}

\subsection{Crypto}
\label{implemenation:libs:cr}

The crypto library provides various cryptographic functionalities. It wraps various \verb|SJCL| and \verb|Node.js Crypto module| functions.

Functions:

\begin{itemize}
  \item \verb|generateKeyPair|: Generate an asymmetric encryption key pair
  \item \verb|generateKey|: Generate a symmetric encryption key
  \item \verb|pubEncrypt|: Encrypt a string with a public key with the use of ECC
  \item \verb|pubDecrypt|: Decrypt a ciphertext with a secret key with the use of ECC
  \item \verb|encryptFile|: Encrypt a file with a symmetric key with the use of AES256
  \item \verb|decryptFile|: Decrypt a file with a symmetric key with the use of AES256
  \item \verb|bytesToHex|: Convert bytes to a hex
  \item \verb|hextoBytes|: Convert a hex to bytes
  \item \verb|hashFile|: Hash a file with the use of SHA256
  \item \verb|hash|: Hash an array of values with the use of SHA256
\end{itemize}

\section{Command-line interface}
\label{implemenation:cli}

A command-line interface that provides a set of useful commands for the data sharing application.

Usage:

\begin{verbatim}
  $ node data-cli <options>
\end{verbatim}

Options:

\begin{itemize}
  \item \verb|-v| or \verb|--version|: Output the version number
  \item \verb|-g| or \verb|--generate-keys|: Generate an asymmetric
  \item \verb|-k| or \verb|--generate-key|: Generate a symmetric key
  \item \verb|-d| or \verb|--dummy-file <file>|: Generate a 45MB dummy file
  \item \verb|-e| or \verb|--encrypt-file <file>|: Encrypt a file
  \item \verb|-a| or \verb|--evaluation <bytes>|: Evaluate gas cost of bytes on Ethereum
  \item \verb|-s| or \verb|--hash <hash>|: Hash an array of values with SHA256
  \item \verb|-f| or \verb|--hash-file <file>|: Hash a file with SHA256
  \item \verb|-h| or \verb|--help|: Output usage information
\end{itemize}

\section{Smart contracts}
\label{implemenation:contracts}

The data sharing application is governed by a smart contract deployed on the Ethereum network. The smart contract contains the logic of the application. Thought the smart contract one can register a new dataset, request for data processing, register a data controller or a data processor, and save a ZKP proof along with the output of the computation. The data sharing smart contract is publicly available and can be used by any other contract in the network.

\subsection{Data set registration}
\label{implemenation:contracts:data_reg}

In order to register a new data set to the application an entity needs to call the \verb|registerDataSet| function with the following arguments:

\begin{itemize}
  \item \verb|_id|: The id of the data set. Data sets ids must be unique and will be converted to lowercase. It can be any string as long as it have not been already registered and it's length is less that 32
  \item \verb|name|: The name of the data set. It can be an arbitrary string
  \item \verb|location|: The URI of the location of the data set
  \item \verb|category|: The category of the data set. It can be an arbitrary string
  \item \verb|hashMeta|: The SHA256 of the submitted values
  \item \verb|_dataOwner|: The address of the owner of the data source
  \item \verb|digest|: The SHA256 of the raw data set
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Data set registration function}]
  function registerDataSet(
        bytes32 _id,
        string name,
        string location,
        string category,
        string hashMeta,
        address _dataOwner,
        string digest
  ) public returns (bool success);
\end{lstlisting}

\subsection{Request for processing}
\label{implemenation:contracts:req_pr}

The request for processing consists of two parts: A show of interest by a requestor for data processing and a notification to the processor informing that there is a request that needs attention.

In order to request for data processing the \verb|requestProcessing| function needs to be invoked with the following arguments:

\begin{itemize}
  \item \verb|_dataSetID|: The id of the dataset of interest
  \item \verb|_subscriber|: The address of the requestor
  \item \verb|queryID|: The id of the algorithm that the processor will apply over the data set
  \item \verb|pubKey|: The public key of the requestor
\end{itemize}

In order to notify a data processor that a request for data processing is pending a call to the \verb|notifyProcessor| function must be made with the following arguments:

\begin{itemize}
  \item \verb|_providerAddress|: The address of the owner of the data source
  \item \verb|_subscriber|: The address of the requestor
  \item \verb|cipher|: The encryption of the symmetric key with which the dataset has been encrypted
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Request for processing functions}]
  function requestProcessing(
    bytes32 _dataSetID,
    address _subscriber,
    bytes32 queryID,
    string pubKey
  ) public returns (bool success);

  function notifyProcessor(
    address _providerAddress,
    address _subscriber,
    string cipher
  ) public returns (bool success);

\end{lstlisting}

\subsection{Processor Registration}
\label{implemenation:contracts:reg_processor}

A data processor can be registered by a transaction that invokes the  \verb|registerProcessor| function with the following inputs:

\begin{itemize}
  \item \verb|_processorAddress|: The address of the data processor
  \item \verb|name|: The name of the data processor. It can be an arbitrary string
  \item \verb|pubKey|: The public key of the data processor
\end{itemize}

Only the contract creator can execute the \verb|registerProcessor| function.

\begin{lstlisting}[language=Solidity, caption={Data processor registration function}]
  function registerProcessor(
    address _processorAddress,
    bytes32 name,
    string pubKey
  ) public returns (bool success);
\end{lstlisting}

\subsection{Data Controller Registration}
\label{implemenation:contracts:reg_processor}

Likewise, a data processor can be registered by a transaction that invokes the \verb|registerProvider| function with the following inputs:

\begin{itemize}
  \item \verb|_providerAddress|: The address of the data controller
  \item \verb|name|: The name of the data controller. It can be an arbitrary string
  \item \verb|pubKey|: The public key of the data controller
\end{itemize}

Again, only the contract creator can execute the \verb|registerProvider| function.

\begin{lstlisting}[language=Solidity, caption={Data controller registration function}]
  function registerProvider(
    address _providerAddress,
    bytes32 name,
    string pubKey
  ) public returns (bool success);
\end{lstlisting}

\subsection{General functions}
\label{implemenation:contracts:general}

Various general function are provided to facilitate the usage of the system.

\begin{itemize}
  \item \verb|getDataSetInfo|: Given a data set id it returns all the information of the specific data set
  \item \verb|getRequestInfo|: Given a requestor address it returns all the information of the specific request
  \item \verb|getDataProviderInfo|: Given a data controller address it returns all the information of the specific data controller
  \item \verb|getDataProcessorInfo|: Given a data processor address it returns all the information of the specific data processor
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={General functions}]
  function getDataSetInfo(bytes32 _dataSetID)
    public
    view
    returns(
          string name,
          string location,
          string category,
          address owner,
          string hashMeta,
          string digest
      );

  function getRequestInfo(address _subscriber)
    public
    view
    returns(
      bytes32 dataSetID,
      address provider,
      bool hasProof,
      bool processed,
      bytes32 queryID,
      string pubKey
  );

  function getDataProviderInfo(address provider)
    public
    view
    returns(
      address owner,
      bytes32 name,
      string pubKey
  );

  function getDataProcessorInfo(address _dataProcessorAddress)
  public
  view
  returns(
      address owner,
      bytes32 name,
      string pubKey
  );
\end{lstlisting}

\subsection{Zero Knowledge Proof}
\label{implemenation:contracts:zkp}

A data processor can save the ZKP proof and the output of the computation by calling the \verb|addProof| function with the following arguments:

\begin{itemize}
  \item \verb|_subscriber|: The address of the requestor
  \item \verb|proof|: The proof in hex format
  \item \verb|output|: The encrypted output
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Data sharing application events}]

function addProof(
  address _requestor,
  string proof,
  string output
) public returns (bool success);

\end{lstlisting}
\subsection{Events}
\label{implemenation:contracts:events}

Every function that is invoked by a signed transaction emits an event notifying the occurrence of the action by a specific participant. Every node of the network can register and listen to this events.

In particular:

\begin{itemize}
  \item \verb|NewDataSet|: A data set is registered
  \item \verb|NewProvider|: A data controller is registered
  \item \verb|NewProcessor|: A data processor is registered
  \item \verb|NewRequest|: A request for processing is made
  \item \verb|Process|: A notification for data processing is sent to a specific processor
\end{itemize}

\begin{lstlisting}[language=Solidity, caption={Data sharing application events}]

  event NewDataSet(
    bytes32 _id,
    string name,
    string location,
    string category,
    string hashMeta,
    address owner,
    string digest
  );

  event NewProvider(
    address _providerAddress,
    bytes32 name
  );

  event NewProcessor(
    address _providerAddress,
    bytes32 name,
    string pubKey
  );

  event NewRequest(
    bytes32 _dataSetID,
    address _provider,
    address _subscriber,
    bytes32 queryID,
    string pubKey
  );
  event Process(
    address _providerAddress,
    address _subscriber,
    string cipher
  );
\end{lstlisting}

\section{Zero Knowledge Proofs}
\label{implemenation:zkp}

To generate and verify zkSNARKs proofs the \verb|Pequin| library~\cite{pequin} is used. \verb|Pequin| is a toolchain to verifiably execute programs expressed in the C programming language. \verb|Pequin| consists of a front-end and a back-end. The front-end takes C programs and transforms them to a set of arithmetic constraints as described in ~\ref{zkp:snarks}. The back-end in Pequin is a zk-SNARK. Pequin uses \verb|SCIPR Lab's libsnark|~\cite{libsnark}, which is an optimized implementation of the back-end of \verb|Pinocchio|~\cite{pinocchio-nearly-practical-verifiable-computation}, itself a refinement and implementation of \verb|GGPR|~\cite{ggpr}.

Each of the supported algorithm (§~\ref{solution:algorithms}) is written in the C programming language. A trusted setup has been run and a key pair $(e_k, v_k)$ has been generated for each of the available algorithms. The evaluation keys and the compiled programs are available to all data processors as they are necessary components for proof generation and data computation. The verification keys are also publicly available to all requestors as they are needed for the proof verification.

A set of various bash scripts are made to facilitate the data processors and the data requestors. They provide simple commands and abstract the interaction with the \verb|Pequin| library.

\section{Programming details}
\label{implemenation:details}

Building the data sharing ecosystem (§~\ref{solution}) requires the use of various frameworks, technologies, programming languages and libraries.

In particular:

\begin{enumerate}
  \item RESTful API: \verb|Node.js v8.9.4|~\cite{nodejs}, \verb|Express 4.16.2|~\cite{expressjs}
  \item Command-line interface: \verb|Node.js v8.9.4|
  \item Distributed application: \verb|React 15.6.1|~\cite{react}, \verb|Redux 3.7.2|~\cite{redux} and \verb|Bootstrap 4.0.0|~\cite{bootstrap}
  \item Processor node: \verb|Node.js v8.9.4|
  \item Controller node: \verb|Node.js v8.9.4|
  \item Libraries:
    \begin{enumerate}
      \item Blockchain: \verb|web3 0.20.4|~\cite{web3js}
      \item Crypto: \verb|SJCL 1.0.7|~\cite{sjcl} and \verb|Node.js v8.9.4 Crypto Module|
    \end{enumerate}
  \item Smart contracts: \verb|Truffle 4.1.0|~\cite{truffle} and \verb|Solidity 0.4.19|~\cite{solidity}
  \item Zero Knowledge Proofs: \verb|Pequin|~\cite{pequin} and \verb|libsnark|~\cite{libsnark}
  \item Ethereum Blockchain: \verb|Ganache CLI v6.0.3 (ganache-core: 2.0.2)|~\cite{ganache}
\end{enumerate}

All code written in \verb|JavaScript| follows the \verb|ES6 (ECMAScript 2015)|~\cite{ECMA_2015} standard and the  \verb|StandardJS|~\cite{stdjs} style guide.

\begin{figure}[ht!]
  \center
  \begin{tikzpicture}
    \begin{scope}[node distance=2cm]
      \node[entity] (api) {API};
      \node[entity] (dapp) [above=of api] {Dapp};
      \node[entity] (eth_node) [below=of api] {Ethereum node};
      \node[database] (db) [right=of api, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (api) -- (eth_node);
    \draw[com] (api) -- (dapp);
    \draw[com] (api.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(dapp) (eth_node) (db), label={Local Enviroment}] (local) {};

    \node[barstyle={local}{Ethereum Blockchain}, below=of local] (blockchain) {};

    \draw[com] (eth_node.south) ++ (south:0ex) -- ++ (south:1.35cm);

  \end{tikzpicture}
  \caption{REST API \& Dapp implemenation scheme}
  \label{fig:implemenation:rest}
\end{figure}

\begin{figure}[ht!]
  \center
  \begin{tikzpicture}

    \begin{scope}[node distance=2cm]
      \node[entity] (controller) {Controller};
      \node[entity] (eth_node) [below=of controller] {Ethereum node};
      \node[database] (db) [right=of controller, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (controller) -- (eth_node);
    \draw[com] (controller.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(controller) (eth_node) (db), label={Local Enviroment}] (local) {};

    \node[barstyle={local}{Ethereum Blockchain}, below=of local] (blockchain) {};

    \draw[com] (eth_node.south) ++ (south:0ex) -- ++ (south:1.35cm);

    \begin{scope}[node distance=2cm]
      \node[entity] (eth_node_pr) [below=of blockchain, xshift=-2cm, yshift=0.65cm] {Ethereum node};
      \node[entity] (processor) [below=of eth_node_pr] {Processor};
      \node[entity] (zkp) [below=of processor] {ZKP};
      \node[database] (db_pr) [right=of processor, yshift=-0.3cm] {Mongodb};
    \end{scope}

    \draw[com] (eth_node_pr.north) ++ (north:0ex) -- ++ (north:1.35cm);
    \draw[com] (processor) -- (eth_node_pr);
    \draw[com] (processor) -- (zkp);
    \draw[com] (processor.east) ++ (right:0ex) -- ++ (right:2cm);

    \node[block,fit=(eth_node_pr) (processor) (db_pr) (zkp), label={below:Local Enviroment}] (local) {};

  \end{tikzpicture}
  \caption{Data processor and data controller implemenation scheme}
  \label{fig:implemenation:con_pr}
\end{figure}
