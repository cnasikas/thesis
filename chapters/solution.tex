%!TEX root = ../thesis.tex
\chapter{Solution}
\label{solution}

Blockchain is used as the controller of the application. It is responsible for keeping an
audit immutable log of all actions of the participants. All interaction are being made
through the blockchain supporting data accountability and provenance tracking. It should be mention that blockchain does not offers an extra security layer as the data are off-chain and data silos remain a single point of failure.

\section{Architecture}
\label{solution:architecture}

There are three main roles consisting the application: the data controller, the data processor
and the data requester. The first two are also defined in the context of GDPR (§~\ref{problem:regulations}).
GDPR defines another role, that of data subject-the owner of the data.
In our scheme we assume that the data controller already has permission to access the data or
she is at the same time the data subject and the data controller.

\subsection{Data Controller}
\label{solution:arc:data_controller}

The data controller is in charge of a data set. She run on behalf of a data subject (person)
that authorizes the data controller to access her personal data, with the possibility of forwarding
them to a data processor that will be responsible for processing the data on behalf of controller~\cite{DBLP:journals/corr/NeisseSF17}.

\subsection{Data Processor}
\label{solution:arc:data_processor}

The data processor is responsible for processing data on behalf of the data requester. She listens
for requests and fulfil them on submission. Furthermore, she submits a Zero Knowledge Proof of correct computation over a data set.

\subsection{Data Requester}
\label{solution:arc:data_req}

The requester can be any entity that requests a computation over a data set. It can be a research center, a university, a machine learning algorithm or any individual. The requester expects, along with the output, a proof of correct computation, over a specific data set, that verifies at the end of the interaction with the processor.

\subsection{Queries}
\label{solution:arc:queries}

The system should support only a set of open pre-fabricated queries that have been analyzed and constructed to be privacy-preserving with the use of techniques such as k-anonymity~\cite{Samarati98protectingprivacy} and l-diversity~\cite{Aggarwal2008}. The queries return only de-identified aggregated results.

The supported queries are:

\begin{enumerate}
  \item Sum
  \item Average
  \item Count
  \item Maximum
  \item Median
  \item Minimum
\end{enumerate}

The above queries are not considered to be privacy-preserving as it is outside the scope of the initial prototype and should be implemented on future work.

\subsection{Consent}
\label{solution:arc:consent}

Modeling dynamic consent in smart contracts should be carefully analyzed taking into account design issues that are related to smart contracts lifecycle, required state variables for storing contract’s information, and access restrictions to those variables.

Neisse et al.~\cite{DBLP:journals/corr/NeisseSF17} proposed the following three models for data accountability and provenance tracking that comply with the GDPR(§~\ref{problem:regulations}):

\begin{enumerate}
  \item Contract for a specific controller: A contract where the data subject creates a contract tailored for each data controller
  \item Contract for specific data: A contract where each subject’s data instance is shared among all data controllers
  \item Contract for multiple data subjects: A contract where the data controller specifies how the data from all subjects are treated from the controller
\end{enumerate}

The first contract is more adequate for sensitive data~\cite{DBLP:journals/corr/NeisseSF17}, such as health data, since a subject-controller relationship~\cite{Azaria2016} is being created where each patient has a different contract for each controller accessing their data, providing fine grained access control and provenance information. On the other hand, it has the highest cardinality among the others two types~\cite{DBLP:journals/corr/NeisseSF17}. The second contract suffers from direct linkability as a unique subject address is needed compromising patients’ privacy~\cite{DBLP:journals/corr/NeisseSF17}. Lastly, the third one has the lowest cardinality among the others but also has the lower level of customization due to the limited number of contract options~\cite{DBLP:journals/corr/NeisseSF17}.

\subsection{Flow}
\label{solution:arc:flow}

\begin{enumerate}
  \item The controller encrypts a data set with a symmetric key and saves the cipher-text to a database
  \item The controller encrypts the symmetric key with the public key of the processor
  \item The requester makes a request of process over some data
  \item The processor process the data on behalf of the request and submits the result of the computation on the
  blockchain along with a Zero Knowledge Proof (§~\ref{zkp}) of the correctness of the computation.
  \item The requester gets the results and verifies the proof.
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}[
        database/.style={
        cylinder,
        shape border rotate=90,
        aspect=0.5,
        draw
      },
      txt/.style={
      }
    ]

    \node[draw,rectangle,minimum width=\textwidth, minimum height=1cm,anchor=west] (blockchain) at (0,0){Blockchain};

    \begin{scope}[node distance=4cm]
      \node[draw, minimum height=1cm, minimum width=4cm, anchor=west] (owner) at (0,-5) {Data Controller};
      \node[database] (db) [below right=of owner] {Database};
      \draw[<->] (owner) -- (db);
      \draw[<-] ([xshift=-1em]owner.north) -- ([xshift=-1em]2,-0.5);
      \draw[->] ([xshift=1em]owner.north) -- ([xshift=1em]2,-0.5);
    \end{scope}

    \node[txt] (enc_db) [below=of owner,yshift=-1.5em, xshift=3em] {$Enc_k(data)$};
    \node[txt] (enc_key) [above=of owner, xshift=6.5em, yshift=1em] {$Enc_{pk_P}(k, metadata)$};

    \begin{scope}
      \node[draw, minimum height=1cm, minimum width=4cm, anchor=west] (processor) at (0,5) {Data Processor};
      \draw[<-] ([xshift=-1em]processor.south) -- ([xshift=-1em]2,0.5);
      \draw[->] ([xshift=1em]processor.south) -- ([xshift=1em]2,0.5);
    \end{scope}

    \node[txt] (enc_db) [below=of processor,yshift=-1.5em, xshift=6em] {$Enc_{pk_R}(result, \pi)$};

    \begin{scope}
      \node[draw, minimum height=1cm, minimum width=4cm, anchor=east] (requester) at (\textwidth,-5) {Requester};
      \draw[->] ([xshift=-1em]requester.north) -- ([xshift=-1em]14.45,-0.5);
      \draw[<-] ([xshift=1em]requester.north) -- ([xshift=1em]14.45,-0.5);
    \end{scope}

    \node[txt] (enc_db) [above left=of requester, xshift=5.5em] {$Request(pk_R, pred)$};
    \node[txt] (enc_db) [above right=of requester, xshift=-5.5em] {$Verify_{vk}(\pi)$};

  \end{tikzpicture}
  \caption{Architecture}
  \label{fig:architecture}
\end{figure}
