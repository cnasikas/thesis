%!TEX root = ../thesis.tex
\chapter{Solution}
\label{solution}

In our solution the Blockchain is used as the controller of the application. It is responsible for keeping an
audit, immutable, tamper-proof and transparent log of all actions of the participants.

Blockchain does not provides an extra security layer concerning datasets. The datasets are stored off-chain, data controllers are responsible for the security of their system and the participants can still collaborate outside the Blockchain network. Nevertheless, the use of the Blockchain can guarantee accountability, auditability and provenance tracking of the data increasing the trust for the system.

\section{Entities}
\label{solution:entities}

There are three main roles consisting the application: the data controller, the data processor
and the data requester. The first two are also defined in the context of GDPR (§~\ref{problem:regulations}).
GDPR defines another role, that of data subject; the owner of the data.
In our scheme we assume that the data controller already has consent to access or forward the data or she is at the same time the data subject and the data controller.

\subsection{Data Controller}
\label{solution:entities:data_controller}

The data controller is in charge of a data set. She run on behalf of a data subject (person)
that authorizes the data controller to access her personal data, with the possibility of forwarding
them to a data processor that will be responsible for processing the data on behalf of controller~\cite{DBLP:journals/corr/NeisseSF17}.

\subsection{Data Processor}
\label{solution:entities:data_processor}

The data processor is responsible for processing data on behalf of the data controller. She listens for data processing requests and returns, along with the output of the process, a Zero Knowledge Proof of correct computation over the requested data set.

\subsection{Data Requester}
\label{solution:entities:data_req}

The requester can be any entity that requests a computation over a data set. It can be a research center, a university, a machine learning algorithm or any individual. The requester expects, along with the output, a proof of correct computation over the requested data set that verifies at the end of the processing.

\section{Trust model}
\label{solution:trust_model}

Before we explain in detail our architecture, we would like to introduce our thread model and what exactly our goals are. It is important to understand the possible roles of adversaries, their strengths and their resources.

Adversaries can be categories in 3 categories, as the involved parties:

\begin{itemize}
  \item Malicious data controller
  \item Malicious data processor
  \item Malicious data requestor
\end{itemize}

In our model we assume that the involved entities that interact with a data set---the data controller and the data processor---are identified and verified through a public key infrastructure (PKI)~\cite{adams_understanding_2003}. Furthermore, each entity is a trusted entity with certain trust properties. In particular, the data controller is trusted for integrity and confidentiality and the data processor only for confidentiality.

\section{Queries}
\label{solution:queries}

The system should support only a set of open pre-fabricated queries that have been analyzed and constructed to be privacy-preserving with the use of techniques such as k-anonymity~\cite{Samarati98protectingprivacy} and l-diversity~\cite{Aggarwal2008}. The queries return only de-identified aggregated results.

The supported queries are:

\begin{enumerate}
  \item Sum
  \item Average
  \item Count
  \item Maximum
  \item Median
  \item Minimum
\end{enumerate}

The above queries are not considered to be privacy-preserving as it is outside the scope of the initial prototype and should be implemented on future work.

\section{Consent}
\label{solution:consent}

Modeling dynamic consent in smart contracts should be carefully analyzed taking into account design issues that are related to smart contracts lifecycle, required state variables for storing contract’s information, and access restrictions to those variables.

Neisse et al.~\cite{DBLP:journals/corr/NeisseSF17} proposed the following three models for data accountability and provenance tracking that comply with the GDPR(§~\ref{problem:regulations}):

\begin{enumerate}
  \item Contract for a specific controller: A contract where the data subject creates a contract tailored for each data controller
  \item Contract for specific data: A contract where each subject’s data instance is shared among all data controllers
  \item Contract for multiple data subjects: A contract where the data controller specifies how the data from all subjects are treated from the controller
\end{enumerate}

The first contract is more adequate for sensitive data~\cite{DBLP:journals/corr/NeisseSF17}, such as health data, since a subject-controller relationship~\cite{Azaria2016} is being created where each patient has a different contract for each controller accessing their data, providing fine grained access control and provenance information. On the other hand, it has the highest cardinality among the others two types~\cite{DBLP:journals/corr/NeisseSF17}. The second contract suffers from direct linkability as a unique subject address is needed compromising patients’ privacy~\cite{DBLP:journals/corr/NeisseSF17}. Lastly, the third one has the lowest cardinality among the others but also has the lower level of customization due to the limited number of contract options~\cite{DBLP:journals/corr/NeisseSF17}.

\section{Flow}
\label{solution:flow}

\subsection{Dataset Registration}
\label{solution:flow:reg_data}

A data controller:

\begin{enumerate}
  \item Encrypts a data set with a symmetric key and save it to a specific location
  \item Registers the data set by initiating a transaction that saves the data set's metadata (name, location, category, digest) on the Blockchain.
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}
    \node[blockchain] (blockchain) at (0,0){Blockchain};

    \begin{scope}[node distance=4cm]
      \node[node, anchor=west] (owner) at (0,-5) {Data Controller};
      \node[database] (db) [below right=of owner] {Datastore};
      \draw[<->] (owner) -- (db) node[midway,left] {$Enc_k(data)$};
      \draw[<-] ([xshift=-1em]owner.north) -- ([xshift=-1em]2,-0.5);
      \draw[->] ([xshift=1em]owner.north) -- ([xshift=1em]2,-0.5) node[midway,right] {$Tx(\{name, location, category, digest, address, hashMeta\}, "register\_data")$};
    \end{scope}

  \end{tikzpicture}
  \caption{Data registration}
  \label{fig:arc:reg}
\end{figure}

\subsection{Data Controller Registration}
\label{solution:flow:con_reg}

\begin{enumerate}
  \item Data controller generates an asymmetric encryption key pair
  \item A trusted entity registers data controller's availability by initiating a transaction that saves processors name and public key on the blockchain
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}

    \node[blockchain] (blockchain) at (0,0){Blockchain};


    \begin{scope}
      \node[node, anchor=west] (controller) at (0,5) {Data Controller};
      \draw[<-] ([xshift=-1em]controller.south) -- ([xshift=-1em]2,0.5);
      \draw[->] ([xshift=1em]controller.south) -- ([xshift=1em]2,0.5) node[midway,right] {$Tx(\{name, pubKey, address\}, "register\_controller")$};
    \end{scope}

  \end{tikzpicture}
  \caption{Controller Registration}
  \label{fig:arch:con_reg}
\end{figure}

\subsection{Data Processor Registration}
\label{solution:flow:pr_reg}

\begin{enumerate}
  \item Data processor generates an asymmetric encryption key pair
  \item A trusted entity registers processor's availability by initiating a transaction that saves processors name and public key on the blockchain
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}

    \node[blockchain] (blockchain) at (0,0){Blockchain};


    \begin{scope}
      \node[node, anchor=west] (processor) at (0,5) {Data Processor};
      \draw[<-] ([xshift=-1em]processor.south) -- ([xshift=-1em]2,0.5);
      \draw[->] ([xshift=1em]processor.south) -- ([xshift=1em]2,0.5) node[midway,right] {$Tx(\{name, pubKey, address\}, "register\_processor")$};
    \end{scope}

  \end{tikzpicture}
  \caption{Processor Registration}
  \label{fig:arch:pr_reg}
\end{figure}

\subsection{Request for processing}
\label{solution:flow:pr_req}

\begin{enumerate}
  \item The requestor selects a data set on which the processing should be made and  notify the network participants of the request by initiating a transaction on the blockchain passing along her public key
\end{enumerate}

\subsection{Handle request for processing}
\label{solution:flow:handle_request}

\begin{enumerate}
  \item The controller, responsible for the desired data set, selects a processor and encrypts the symmetric key with the public key of the selected processor
  \item The controller notifies the processor by initiating a transaction on the blockchain passing all needed information such as the encrypted symmetric key and the request ID.
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}

    \node[blockchain] (blockchain) at (0,0){Blockchain};

    \begin{scope}[node distance=4cm]
      \node[node, anchor=west] (owner) at (0,-5) {Data Controller};
      \draw[->] ([xshift=0em]owner.north) -- ([xshift=0em]2,-0.5);
    \end{scope}

    \node[txt] (list_req) [below=of owner, xshift=0em, yshift=1.5em] {$listen("request\_processing")$};

    \begin{scope}
      \node[node, anchor=west] (processor) at (0,5) {Data Processor};
      \draw[<-] ([xshift=0em]processor.south) -- ([xshift=0em]2,0.5) node[midway,right] {$Tx(\{requestID, Enc_{pk_P}(k)\}, "notify\_processor")$};
    \end{scope}

    \node[txt] (list_req_cr) [above=of processor, xshift=0em, yshift=-1.5em] {$listen("processing")$};

    \begin{scope}
      \node[node, anchor=east] (requester) at (\textwidth,-5) {Requester};
      \draw[->] ([xshift=0em]requester.north) -- ([xshift=0em]14.45,-0.5) node[midway,left] {\small $Tx(\{dataSetID, queryID, pubKey, address\}, "request\_processing")$};
    \end{scope}

  \end{tikzpicture}
  \caption{Request for processing}
  \label{fig:arch:req_pr}
\end{figure}

\subsection{Data set processing}
\label{solution:flow:pr_data}

A data processor:

\begin{enumerate}
  \item Get the symmetric key
  \item Decrypt the data set
  \item Process the data
  \item Creates a Zero Knowledge Proof (§~\ref{zkp}) of the correctness of the computation for the specific dataset
  \item Encrypts the results with the public key of the requestor
  \item Submits the encrypted result of the computation on the Blockchain along with the proof.
\end{enumerate}

\begin{figure}[ht!]
  \begin{tikzpicture}

    \node[blockchain] (blockchain) at (0,0){Blockchain};

    \begin{scope}
      \node[node, anchor=west] (processor) at (0,5) {Data Processor};
      \draw[->] ([xshift=0em]processor.south) -- ([xshift=0em]2,0.5) node[midway,right] {$Tx(\{requestID, Enc_{pk_R}(\pi, y)\}, "notify\_requester")$};
    \end{scope}

    \node[node, process] (compute) [above of=processor, yshift=3cm] {$Compute$};

    \draw[->] ([xshift=-1em]compute.south) -- ([xshift=-1em]2,5.5) node[midway,left] {$(y, \pi)$};
    \draw[<-] ([xshift=1em]compute.south) -- ([xshift=1em]2,5.5)  node[midway,right] {$dataset$};

    \begin{scope}
      \node[node, anchor=east] (requester) at (\textwidth,-5) {Requester};
      \draw[<-] (requester.north) -- (14.45,-0.5) node[midway,right] {$Verify_{vk}(\pi, y)$};
    \end{scope}

  \end{tikzpicture}
  \caption{Data processing}
  \label{fig:arch:process}
\end{figure}

\section{Processor Selection}
\label{solution:pr_selection}

The choice of the data processor that will satisfy the current processing request is done sequentially. Every time a request for processing is made the data controller choose the next in line data processor.

\section{Proof of correctness of computation}
\label{solution:proof}

Let $d$ be a private dataset, $H$ a cryptographic hash function and $h = H(d)$ the digest of $d$ over $H$. Let $\calp$ be a prover (data processor) and $\calv$ the verifier (data requester). Prover $\calp$ produces a zk-SNARK proof (§~\ref{zkp:snarks}) $\pi$ for the following NP statement:

\blockquote{
  Given the digest $h$, an outsourced function $F$ and an output $y$ I know a private dataset $d$ such that:
    \begin{itemize}
      \item $H(d) = h$
      \item $F(d) = y$
    \end{itemize}
}

The proof $\pi$ allows to a prover $\calp$ to prove to a verifier $\calv$ that computation is done at the specific dataset $d$, the verifier chose, without revealing the dataset itself.

The irreversibility of cryptographic hash function in conjunction with the immutability of Blockchain and the trust for data integrity to data controller, that produced the digest of the dataset in the first place, guarantees that indeed the prover $\calp$ processed the requested dataset.

\begin{figure}[ht!]
  \begin{tikzpicture}

    \node[blockchain] (blockchain) at (0,0){Blockchain};

    \begin{scope}[node distance=4cm]
      \node[node, anchor=west] (owner) at (0,-5) {Data Controller};
      \node[database] (db) [below right=of owner] {Database};
      \draw[<->] (owner) -- (db) node[midway,left] {$Enc_k(data)$};
      \draw[<-] ([xshift=-1em]owner.north) -- ([xshift=-1em]2,-0.5);
      \draw[->] ([xshift=1em]owner.north) -- ([xshift=1em]2,-0.5) node[midway,right] {$Enc_{pk_P}(k, metadata)$};
    \end{scope}

    \begin{scope}
      \node[node, anchor=west] (processor) at (0,5) {Data Processor};
      \draw[<-] ([xshift=-1em]processor.south) -- ([xshift=-1em]2,0.5);
      \draw[->] ([xshift=1em]processor.south) -- ([xshift=1em]2,0.5) node[midway,right] {$Enc_{pk_R}(result, \pi)$};
    \end{scope}

    \begin{scope}
      \node[node, anchor=east] (requester) at (\textwidth,-5) {Requester};
      \draw[->] ([xshift=-1em]requester.north) -- ([xshift=-1em]14.45,-0.5) node[midway,left] {$Request(pk_R, pred)$};
      \draw[<-] ([xshift=1em]requester.north) -- ([xshift=1em]14.45,-0.5) node[midway,right]  {$Verify_{vk}(\pi)$};
    \end{scope}

  \end{tikzpicture}
  \caption{Architecture}
  \label{fig:architecture}
\end{figure}
